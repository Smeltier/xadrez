@startuml class_diagram

skinparam linetype ortho
left to right direction
skinparam classArrowColor black
skinparam nodesep 80
skinparam ranksep 80

skinparam ClassDiagram {
    ArrowThickness 1
    ArrowColor black
    HorizontalSpacing 60
    VerticalSpacing 60
    ArrowFontSize 11
    ArrowFontColor black
    ArrowFontStyle plain
}

class Board <<entity>> {
  - boardsize : Integer
  - board : Piece[][]
  - enPassantVulnerable : Position
  + Board(size: Integer)
  + getPieceAt(position : Position) : Piece
  + setPieceAt(position : Position, piece : Piece) : void
  + isOnLimits(position : Position) : boolean
  + getBoardsize() : Integer
  + setBoardsize(boardsize: Integer) : void
  + getEnPassantVulnerable() : Position
  + setEnPassantVulnerable(position : Position) : void
}

class Position <<immutable>> {
  - row : Integer
  - col : Integer
  + Position(row : Integer, col : Integer)
  + getCol() : Integer
  + getRow() : Integer
  + equals(obj : Object) : boolean
  + hashCode() : int
  + toString() : String
}

class Move <<immutable>> {
  - piece : Piece
  - capturedPiece : Piece
  - from : Position
  - to : Position
  + Move(piece : Piece, from : Position, to : Position, capturedPiece : Piece)
  + getCapturedPiece() : Piece
  + getPiece() : Piece
  + getOrigin() : Position
  + getDestiny() : Position
  + equals(obj : Object) : boolean
  + hashCode() : int
  + toString() : String
}

abstract class Piece <<entity>> {
  - symbol : String
  # moveCount : Integer
  # color : PieceColor
  # position : Position
  + Piece(symbol : String, color : PieceColor, position : Position)
  + {abstract} getValidMoves(board : Board) : ArrayList<Position>
  + isFirstMove() : boolean
  + decreaseMoveCount() : void
  + getPosition() : Position
  + setPosition(newPosition : Position) : void
  + getColor() : PieceColor
  + getSymbol() : String
  + equals(obj : Object) : boolean
  + hashCode() : int
  + toString() : String
}

abstract class SlidingPiece extends Piece {
  + SlidingPiece(symbol : String, color : PieceColor, position : Position)
  # checkMoveTrajectory(moves : ArrayList<Position>, board : Board, deltaRow : int, deltaCol : int) : void
}

class Bishop extends SlidingPiece {
  + Bishop(color : PieceColor, position : Position)
}

class Rook extends SlidingPiece {
  + Rook(color : PieceColor, position : Position)
}

class Queen extends SlidingPiece {
  + Queen(color : PieceColor, position : Position)
}

class Pawn extends Piece {
  + Pawn(color : PieceColor, position : Position)
  - checkCaptureMove(moves : ArrayList<Position>, board : Board, targetPosition : Position) : void
}

class Knight extends Piece {
  + Knight(color : PieceColor, position : Position)
}

class King extends Piece {
  + King(color : PieceColor, position : Position)
}

enum PieceColor {
  WHITE
  BLACK
}

enum PieceType {
  QUEEN
  KNIGHT
  ROOK
  BISHOP
  PAWN
  KING
}

class PromotionFactory <<factory>> {
  - PromotionFactory()
  + {static} create(type : PieceType, original : Piece) : Piece
}

class StandardBoardFactory <<factory>> {
  + {static} createBoard() : Board
  - {static} setupSide(board : Board, color : PieceColor) : void
}

class SymbolFactory <<factory>> {
  - {static} SYMBOLS : Map<String, String>
  - SymbolFactory()
  + {static} getSymbol(type : PieceType, color : PieceColor) : String
}

exception IllegalArgumentException

exception InvalidPositionException extends IllegalArgumentException {
  + InvalidPositionException(message : String)
}

interface ISpecialMove {
  + canExecute(board : Board, move : Move) : boolean
  + execute(board : Board, move : Move) : void
}

class EnPassant implements ISpecialMove {
}

class Castling implements ISpecialMove {
}

class Promotion implements ISpecialMove {
}

class SpecialMovesRegistry {
    - {static} specialMoves : ArrayList<ISpecialMove>
    + {static} getAll() : List<ISpecialMove>
}

class ChessRules <<utility>> {
  - ChessRules()
  + {static} isMoveLegal(board : Board, move: Move) : boolean
  + {static} isKingInCheck(board : Board, kingColor : PieceColor) : boolean
  + {static} isCheckMate(board : Board, kingColor : PieceColor) : boolean
  + {static} isStalemate(board : Board, color : PieceColor) : boolean
  + {static} isSquareAttacked(board : Board, target : Position, victimColor : PieceColor) : boolean
  - {static} undoMove(board : Board, move: Move) : void
  - {static} findKingPosition(board : Board, color : PieceColor) : Position
  - {static} getPiecesByColor(board : Board, color : PieceColor) : List<Piece>
}

class PieceMover {
  - PieceMover()
  + {static} move(board : Board, move : Move, specials : List<ISpecialMove>) : void
  - {static} applyMove(board : Board, move : Move) : void
}

class MoveReader <<utility>> {
  - MoveReader()
  + {static} parse(input : String) : Position[]
  - {static} convertStringToPosition(s : String) : Position
}

class Player <<immutable>> {
    - name : String
    - color : PieceColor
    + Player(name : String, color : PieceColor)
    + getName() : String
    + getColor() : PieceColor
}

class Game <<control>> {
  - board : Board
  - ui : IUserInterface
  - isRunning : boolean
  - currentPlayerColor : PieceColor
  - whitePlayer : Player
  - blackPlayer : Player
  + Game(ui : IUserInterface)
  + run() : void
  - processTurn() : void
  - validateSourcePosition(from : Position) : void
  - setupPlayers() : void
  - switchTurn() : void
}

interface IUserInterface {
  + showBoard(board : Board) : void
  + showMessage(message : String) : void
  + showMessageWithTimming (message: String, delay: int) : void
  + showError(error : String) : void
  + readInput(prompt : String) : String
  + readMove() : Position[]
  + close() : void
}

class ConsoleUI implements IUserInterface {
  - sc : Scanner
  + ConsoleUI()
}

class ConsoleUtils <<utility>> {
    + {static} ANSI_RESET : String
    + {static} ANSI_WHITE : String
    + {static} ANSI_YELLOW : String
    + {static} ANSI_CYAN : String
    + {static} ANSI_PURPLE_BACKGROUND : String
    + {static} ANSI_BLACK_BACKGROUND : String
    - ConsoleUtils()
    + {static} clearScreen() : void
    + {static} defineUTF8() : void
}

class BoardPrinter <<utility>> {
    - BoardPrinter()
    + {static} print(board : Board) : void
    - {static} printPiece(piece : Piece, background : String) : void
}

class MenuView <<utility>> {
    - ui : IUserInterface
    - MenuView()
    + {static} setUI(ui : IUserInterface) : void
    + {static} startMenu() : void
    + {static} promotionMenu() : void
    + {static} showRules() : void
    + {static} title(message : String) : void
}

class ChessApp {
  + start() : void
}

ChessApp *--> "1" Game
ChessApp ..> MenuView
ChessApp *--> "1" IUserInterface
Game o--> "1" Board 
Game *--> "1" Player 
Game *--> "1" Player 
Game o--> "1" IUserInterface
Game ..> ChessRules
Game ..> PieceMover
Game ..> SpecialMovesRegistry
PieceMover ..> ISpecialMove
PieceMover ..> Board
PieceMover ..> Move
ChessRules ..> Board
ChessRules ..> Piece
ChessRules ..> Move
ChessRules ..> Position
SpecialMovesRegistry *--> "0..*" ISpecialMove
StandardBoardFactory ..> Board
StandardBoardFactory ..> Piece
PromotionFactory ..> Piece
Board o--> "0..*" Piece
Piece o--> "1" Position 
Piece o--> "1" PieceColor 
Piece ..> Board: use
Move --> Piece
Move --> Position
ConsoleUI ..> MoveReader
ConsoleUI ..> BoardPrinter
MenuView --> IUserInterface
BoardPrinter ..> ConsoleUtils
Board ..> InvalidPositionException: throws
PromotionFactory ..> PieceType: use
SymbolFactory ..> PieceType: use
EnPassant ..> Pawn
Castling ..> King
Promotion ..> Pawn

@enduml