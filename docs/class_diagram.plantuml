@startuml class_diagram

' skinparam linetype ortho
' left to right direction
' skinparam classArrowColor black
' skinparam nodesep 80
' skinparam ranksep 80

' skinparam ClassDiagram {
'     ArrowThickness 1
'     ArrowColor black
'     HorizontalSpacing 60
'     VerticalSpacing 60
'     ArrowFontSize 11
'     ArrowFontColor black
'     ArrowFontStyle plain
' }

class Board {
  - BOARDSIZE : Integer = 8
  - board : Piece[][]
  - enPassantVulnerable : Position
  + Board()
  + getPieceAt(position : Position) : Piece
  + setPieceAt(position : Position, piece : Piece) : void
  + isOnLimits(position : Position) : boolean
  + getBOARDSIZE() : Integer
  + getEnPassantVulnerable() : Position
  + setEnPassantVulnerable(position : Position) : void
}

class Position <<immutable>> {
  - row : Integer
  - col : Integer
  + Position(row : Integer, col : Integer)
  + getCol() : Integer
  + getRow() : Integer
  + equals(obj : Object) : boolean
  + hashCode() : int
  + toString() : String
}

class Move {
  - piece : Piece
  - capturedPiece : Piece
  - from : Position
  - to : Position
  + Move(piece : Piece, from : Position, to : Position, capturedPiece : Piece)
  + getCapturedPiece() : Piece
  + getPiece() : Piece
  + getOrigin() : Position
  + getDestiny() : Position
  + equals(obj : Object) : boolean
  + hashCode() : int
  + toString() : String
}

abstract class Piece {
  - symbol : String
  # moveCount : Integer
  # color : PieceColor
  # position : Position
  + Piece(symbol : String, color : PieceColor, position : Position)
  + {abstract} getValidMoves(board : Board) : ArrayList<Position>
  + isFirstMove() : boolean
  + decreaseMoveCount() : void
  + getPosition() : Position
  + setPosition(newPosition : Position) : void
  + getColor() : PieceColor
  + getSymbol() : String
  + equals(obj : Object) : boolean
  + hashCode() : int
  + toString() : String
}

abstract class SlidingPiece extends Piece {
  + SlidingPiece(symbol : String, color : PieceColor, position : Position)
  # checkMoveTrajectory(moves : ArrayList<Position>, board : Board, deltaRow : int, deltaCol : int) : void
}

class Bishop extends SlidingPiece {
  + Bishop(color : PieceColor, position : Position)
  + getValidMoves(board : Board) : ArrayList<Position>
}

class Rook extends SlidingPiece {
  + Rook(color : PieceColor, position : Position)
  + getValidMoves(board : Board) : ArrayList<Position>
}

class Queen extends SlidingPiece {
  + Queen(color : PieceColor, position : Position)
  + getValidMoves(board : Board) : ArrayList<Position>
}

class Pawn extends Piece {
  + Pawn(color : PieceColor, position : Position)
  + getValidMoves(board : Board) : ArrayList<Position>
  - checkCaptureMove(moves : ArrayList<Position>, board : Board, targetPosition : Position) : void
}

class Knight extends Piece {
  + Knight(color : PieceColor, position : Position)
  + getValidMoves(board : Board) : ArrayList<Position>
}

class King extends Piece {
  + King(color : PieceColor, position : Position)
  + getValidMoves(board : Board) : ArrayList<Position>
}

enum PieceColor {
  WHITE
  BLACK
}

enum PieceType {
  QUEEN
  KNIGHT
  ROOK
  BISHOP
  PAWN
  KING
}

class PromotionFactory <<factory>> {
  - PromotionFactory()
  + {static} create(type : PieceType, original : Piece) : Piece
}

class StandardBoardFactory <<factory>> {
  + {static} createBoard() : Board
  - {static} setupSide(board : Board, color : PieceColor) : void
}

class SymbolFactory <<factory>> {
  - {static} SYMBOLS : Map<String, String>
  - SymbolFactory()
  + {static} getSymbol(type : PieceType, color : PieceColor) : String
}

exception IllegalArgumentException

exception InvalidPositionException extends IllegalArgumentException {
  + InvalidPositionException(message : String)
}

interface ISpecialMove {
  + canExecute(board : Board, move : Move) : boolean
  + execute(board : Board, move : Move) : void
}

class EnPassant implements ISpecialMove {
  + canExecute(board : Board, move : Move) : boolean
  + execute(board : Board, move : Move) : void
}

class Castling implements ISpecialMove {
  + canExecute(board : Board, move : Move) : boolean
  + execute(board : Board, move : Move) : void
}

class Promotion implements ISpecialMove {
  + canExecute(board : Board, move : Move) : boolean
  + execute(board : Board, move : Move) : void
}

class SpecialMovesRegistry {
    - {static} specialMoves : ArrayList<ISpecialMove>
    + {static} getAll() : List<ISpecialMove>
}

class ChessRules {
  - ChessRules()
  + {static} isMoveLegal(board : Board, move: Move) : boolean
  + {static} isKingInCheck(board : Board, kingColor : PieceColor) : boolean
  + {static} isCheckMate(board : Board, kingColor : PieceColor) : boolean
  + {static} isStalemate(board : Board, color : PieceColor) : boolean
  + {static} isSquareAttacked(board : Board, target : Position, victimColor : PieceColor) : boolean
  - {static} undoMove(board : Board, move: Move) : void
  - {static} findKingPosition(board : Board, color : PieceColor) : Position
  - {static} getPiecesByColor(board : Board, color : PieceColor) : List<Piece>
}

class PieceMover {
  - PieceMover()
  + {static} move(board : Board, move : Move, specials : List<ISpecialMove>) : void
  - {static} applyMove(board : Board, move : Move) : void
}

class MoveReader {
  - MoveReader()
  + {static} parse(input : String) : Position[]
  - {static} convertStringToPosition(s : String) : Position
}

class Player {
    - name : String
    - color : PieceColor
    + Player(name : String, color : PieceColor)
    + getName() : String
    + getColor() : PieceColor
}

class Game {
  - board : Board
  - ui : IUserInterface
  - isRunning : boolean
  - currentPlayerColor : PieceColor
  - whitePlayer : Player
  - blackPlayer : Player
  + Game(ui : IUserInterface)
  + run() : void
  - processTurn() : void
  - validateSourcePosition(from : Position) : void
  - setupPlayers() : void
  - switchTurn() : void
}

interface IUserInterface {
  + showBoard(board : Board) : void
  + showMessage(message : String) : void
  + showError(error : String) : void
  + readInput(prompt : String) : String
  + readMove() : Position[]
  + close() : void
}

class ConsoleUI implements IUserInterface {
  - sc : Scanner
  + ConsoleUI()
  + showBoard(board : Board) : void
  + showMessage(message : String) : void
  + showError(error : String) : void
  + readInput(prompt : String) : String
  + readMove() : Position[]
  + close() : void
}

class ConsoleUtils <<utility>> {
    + {static} ANSI_RESET : String
    + {static} ANSI_WHITE : String
    + {static} ANSI_YELLOW : String
    + {static} ANSI_CYAN : String
    + {static} ANSI_PURPLE_BACKGROUND : String
    + {static} ANSI_BLACK_BACKGROUND : String
    - ConsoleUtils()
    + {static} clearScreen() : void
    + {static} defineUTF8() : void
}

class BoardPrinter <<utility>> {
    - BoardPrinter()
    + {static} print(board : Board) : void
    - {static} printPiece(piece : Piece, background : String) : void
}

class MenuView <<utility>> {
    - ui : IUserInterface
    - MenuView()
    + {static} setUI(ui : IUserInterface) : void
    + {static} startMenu() : void
    + {static} promotionMenu() : void
    + {static} showRules() : void
    + {static} title(message : String) : void
}

class ChessApp {
  + start() : void
}

ChessApp ..> Game
ChessApp ..> MenuView
ChessApp ..> ConsoleUI

Game o--> Board : board
Game o--> Player : whitePlayer
Game o--> Player : blackPlayer
Game --> IUserInterface
Game ..> ChessRules
Game ..> PieceMover
Game ..> SpecialMovesRegistry

PieceMover ..> ISpecialMove
PieceMover ..> Board
PieceMover ..> Move

ChessRules ..> Board
ChessRules ..> Piece
ChessRules ..> Move
ChessRules ..> Position

SpecialMovesRegistry *--> ISpecialMove

StandardBoardFactory ..> Board
StandardBoardFactory ..> Piece
PromotionFactory ..> Piece

Board o--> Piece : pieces
Piece --> Position : position
Piece --> PieceColor : color

Move --> Piece : piece
Move --> Piece : capturedPiece
Move --> Position : to
Move --> Position : from

ConsoleUI ..> MoveReader
ConsoleUI ..> BoardPrinter

MenuView --> IUserInterface
BoardPrinter ..> ConsoleUtils

Board ..> InvalidPositionException

PromotionFactory ..> PieceType
SymbolFactory ..> PieceType

@enduml